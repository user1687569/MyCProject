函数是C程序的构建块


9.1 函数的定义和调用
double average(double a, double b)
{
    return (a + b) / 2;
}

在函数开始处的double表示average函数的返回类型

标识符a和标识符b(函数的形式参数parameter)表示在调用
average函数时需要提供的两个数。

函数的形式参数本质上是变量, 其初始值在调用函数的时候才提供。

为了调用参数, 需要写出函数名及跟随其后的实际参数列表。
例如, average(x, y)是对average函数的调用.
实际参数用来给函数提供信息;
实际参数不一定要是变量, 任何正确类型的表达式都可以。


9.1.1 函数的定义


9.1.2 函数调用
num_chars = printf("Hi, Mom!\n");

因为我们可能对显示出的字符数量不感兴趣, 所以通常会丢掉printf函数的返回值:
printf("Hi, Mom!\n");

为了清楚地表明函数返回值是被故意丢掉的, C语言允许在函数调用前加上(void):
(void) printf("Hi, Mom!\n");

在C语言中, "强制转换成void"是对"抛弃"的一种客气说法.


9.2 函数声明
[函数声明]  返回类型  函数名  (形式参数);

我们把这类函数声明称为函数原型(function prototype)

C99遵循这样的原则: 在调用一个函数之前, 必须先对其进行声明或定义.
调用函数时, 如果此前编译器未见到该函数的声明或定义, 会导致出错。



9.3 实际参数
形式参数与实际参数之间的差异?
形式参数parameter出现在函数定义中, 它们以假名字来表示函数调用时需要提供的值;
实际参数argument是出现在函数调用中的表达式.

在C语言中, 实际参数是通过值传递的: 调用函数时, 计算出每个实际参数的值并且
把它赋值给相应的形式参数。
在函数执行过程中, 对形式参数的改变并不会影响实际参数的值, 
这是因为形式参数中包含的是实际参数值的副本。
从效果上来说, 每个形式参数的行为好像是把变量初始化成与之匹配的实际参数的值。


9.3.1 实际参数的转换
C语言允许在实际参数的类型与形式参数的类型不匹配的情况下进行函数调用。
1. 编译器在调用前遇到原型。就像使用赋值一样, 每个实际参数的值被隐式地
   转换成相应形式参数的类型。如果把int类型的实际参数传递给期望得到double类型
   数据的函数, 那么实际参数会被自动转换成double类型。


9.3.2 数组型实际参数
数组经常被用作实际参数。当形式参数是一维数组时, 可以不说明数组的长度。
int f(int a[])
{
    ...
}

C语言没有为函数提供任何简便的方法来确定传递给它的数组的长度;
如果函数需要, 我们必须把长度作为额外的参数提供出来。

虽然可以用运算符sizeof计算出数组变量的长度, 但是它无法给出关于数组型
形式参数的正确答案:
int f(int a[])
{
    int len = sizeof(a) / sizeof(a[0]); /* Wrong */
    ...
}

下面的函数说明了一维数组型实际参数的用法.
当给出具有int类型值的数组a时,sum_array函数返回数组a中元素的和。
因为sum_array函数需要知道数组a的长度, 所以必须把长度作为第二个参数提供出来。

int sum_array(int a[], int n)
{
    int i, sum = 0;
    for(i = 0; i < n; i++)
        sum += a[i];

    return sum;
}

如果形式参数是多维数组, 声明参数时只能省略第一维的长度.
int sum_two_dimensional_array(int a[][LEN], int n)
{
    ...
}


9.3.3 变长数组形式参数
C99增加了几个与数组型参数相关的特性。
第一个是变长数组, 这一特性允许我们用非常量表达式指定数组的长度. 变长数组也可以作为参数.

对于新版本的sum_array函数, 其函数原型有好几种写法.
一种写法是使其看起来跟函数定义一样:
int sum_array(int n, int a[n]);

另一种写法是用*(星号)取代数组长度:
int sum_array(int n, int a[*]);

使用*的理由是:函数声明时, 形式参数的名字是可选的。
如果第一个参数定义被省略了, 那么就没有办法说明数组a的长度是n,
而星号的使用则为我们提供了一个线索——数组的长度与形式参数列表中前面的参数相关.


9.3.4 在数组参数声明中使用static (C99)
将static放在数字3之前表明数组a的长度至少可以保证是3:
int sum_array(int a[static 3], int n)
{
    ...
}

这样使用static不会对程序的行为有任何影响。
static的存在只不过是一个"提示".
关于static还有一点值得注意: 
如果数组参数是多维的, static仅可用于第一维(例如, 指定二维数组的行数).


9.3.5 复合字面量 (C99)
int b[] = {3, 0, 3, 4, 1};
total = sum_array(b, 5);
这样写的唯一问题是需要把b作为一个变量声明, 并在调用前进行初始化。
如果b不作它用, 这样做其实有点浪费.

在C99中, 可以使用复合字面量来避免该问题.
total = sum_array((int []){3, 0, 3, 4, 1}, 5);

复合字面量可以包含任意的表达式, 不限于常量.
例如:
total = sum_array((int []){2*i, i+j, j*k}, 3);

如果要求其值为"只读", 可以在类型前加上const:
(const int[]){5, 4};


9.4 return语句


9.5 程序终止

在main函数中执行return语句是终止程序的一种方法,
另一种方法是调用exit函数, 此函数属于<stdlib.h>头.

传递给exit函数的实际参数和main函数的返回值具有相同的含义:
两者都说明程序终止时的状态.
exit(EXIT_SUCCESS);
exit(EXIT_FAILURE);

===================================
return语句 和 exit函数之间的差异是:
不管哪个函数调用exit函数都会导致程序终止;
return语句仅当由main函数调用时才会导致程序终止。


===================================
9.6 递归
如果函数调用它本身, 那么此函数就是递归的.
例如, 利用公式 n! = n x (n - 1)!
下面的函数可以递归地计算出n!的结果
int fact(int n)
{
    if(n <= 1)
        return 1;
    else
        return n * fact(n - 1);
}

下面是递归的另一个示例: 利用公式 X^n = X * X^(n-1) 计算X^n的函数.
int power(int x, int n)
{
    if(n == 0)
        return 1;
    else
        return x * power(x, n - 1);
}

精简power函数:
int power(int x, int n)
{
    return n == 0 ? 1 : x * power(x, n - 1);
}


实际上, 递归经常作为分治法的结果自然地出现。
这种称为分治法的算法设计方法把一个大问题划分成多个较小的问题,
然后采用相同的算法分别解决这些小问题。

分治法的经典示例就是流行的排序算法——快速排序(quick sort).



===================================================
问与答
问: 如果几个函数具有相同的返回类型, 能否把它们的声明合并?
例如, 既然print_pun函数和print_count函数都具有void型的返回类型, 那么下面的声明合法吗?
void print_pun(void), print_count(int n);
答: 合法。
    事实上, C语言甚至允许把函数声明和变量声明合并在一起:
    double x, y, average(double a, double b);
    但是,此种方式的合并声明通常不是个好办法, 它可能会使得程序有点混乱。


问: 在编译main函数时, 为什么编译器会产生"control reaches end of non-void function"
    这样的警告?
答: 尽管main函数有int作为返回类型, 但编译器已经注意到main函数没有return语句.
    在main的末尾放置语句
    return 0;
    将保证编译顺利通过.



