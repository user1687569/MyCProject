======================================
7.1 整数类型
整数类型分为两大类: 有符号型和无符号型

有符号整数和无符号整数
有符号整数如果为正数或零, 那么最左边的位(符号位)为0;
如果是负数, 则符号位为1.

因此, 最大的16位整数的二进制表示形式是 0111 1111 1111 1111,
对应的值是 32767(即 2^15 - 1).
最大的32位整数是 0111 1111 1111 1111 1111 1111 1111 1111,
对应的值是 2147483647 (即 2^31 -1).

不带符号位的整数(最左边的位是数值的一部分)的整数称为无符号整数,
最大的16位无符号整数是65535(即2^16 - 1).

短整型 short int, unsigned short int
长整型 long  int, unsigned long  int

确定整数类型范围的一种方法是检查<limits.h>头,
该头是标准库的一部分, 其中定义了表示每种整数类型的最大值和最小值的宏.

=========================================
C99中提供了两个额外的标准整数类型: 
long long int 和 unsigned long long int

这两个long long 类型要求至少64位宽, 所以
long long int 范围: [-2^63, 2^63 -1],
unsigned long long int 范围: [0, 2^64 - 1].


7.1.2整数常量
常量——在程序中以文本形式出现的数, 而不是读、写或计算出来的数。

C语言允许用十进制(基数为10)、八进制(基数为8)和十六进制(基数为16)
形式书写整数常量。

八进制和十六进制只是书写数的方式, 它们不会对数的实际存储方式产生影响.
整数都是以二进制形式存储的, 跟表示方式无关。

为了强制编译器把常量作为长整数来处理, 只需在后边加上一个字母L(或l):
15L, 0377L, 0x7fffL

为了指明是无符号常量, 可以在常量后边加上字母U(或u):
15U, 0377U, 0x7fffU


7.1.3 C99中的整数常量
在C99中, 以LL或ll(两个字母大小要一致)结尾的整数常量是long long int型的。


7.1.4 整数溢出
整数溢出时的行为要根据操作数是有符号型还是无符号型来确定。
有符号整数运算中发生溢出时, 程序的行为是未定义的。
无符号整数运算过程中发生溢出时, 结果时有定义的:
正确答案是对2取模, 其中n是用于存储结果的位数。
例如,
如果对无符号的16位数65535加1, 其结果可以保证为0.


7.1.5 读/写整数
%d只适用于int类型.

读写无符号整数、短整数和长整数需要一些新的转换说明符。
读写无符号整数时, 使用字母u、o或x代替转换说明中的d.
如果使用u说明符, 该数将以十进制形式读写, 
如果使用o说明符, 该数将以八进制形式读写,
如果使用x说明符, 该数将以十六进制形式读写。

读写短整数时, 在d, o, u或x前面加上字母h;
short s;
scanf("%hd", &s);
printf("%hd", s);


读写长整数时, 在d, o, u或x前面加上字母l;
long l;
scanf("%ld", &l);
printf("%ld", l);


读写长长整数时(仅限C99), 在d, o, u或x前面加上字母ll;
long long ll;
scanf("%lld", &ll);
printf("%lld", ll);


=======================================================
7.2 浮点类型
整数类型并不适用于所有应用。有些时候需要变量能存储带小数点的数，
或者能存储极大数或极小数。
C语言提供了3种浮点类型:
float:  单精度浮点数
double: 双精度浮点数
long double: 扩展精度浮点数

可以在头文件<float.h>中找到定义浮点类型特征的宏。



在C99中, 浮点类型分为两种:
一种是实浮点类型, 包括float, double 和 long double
另一种是C99新增的复数类型, 包括 float _Complex, double _Complex 和 long double _Complex


7.2.1 浮点常量
浮点常量必须包含小数点或指数; 其中, 指数指明了对前面的数进行缩放所需的10的幂次。

默认情况下, 浮点常量都以双精度数的形式存储。换句话说, 当C语言编译器在程序中发现
常量57.0时, 它会安排数据以double类型变量的格式存储在内存中。

为了表明只需要单精度, 可以在常量的末尾处加上字母F或f(如57.0F);
而为了说明常量必须以long double格式存储, 可以在常量的末尾加上字母L或l(如57.0L)

C99提供了十六进制浮点常量的书写规范。十六进制浮点常量以0x或0X开头。这一特性很少用到。


7.2.2 读/写浮点数
转换说明符%e, %f和 %g用于读写单精度浮点数。
读写double 和 long double类型的值所需的转换说明符略有不同。

读取double类型的值时, 在e, f或g前放置字母l;
double d;
scanf("%lf", &d);
注意: 只能在scanf函数格式串中使用l, 不能再printf函数格式串中使用。
在printf函数格式中, 转换e, f和g可以用来写float类型或double类型的值。
(C99允许printf函数调用中使用 %le, %lf和 %lg, 不过字母l不起作用)


读写long double类型的值时, 在e, f或g前放置字母L;
long double ld;

scanf("%Lf", &ld);
printf("%Lf", ld);


7.3 字符类型
通常有符号字符的取值范围是 -128~127
而无符号字符的取值范围则是 0~255


7.3.4 转义序列
转义序列共有两种:字符转义序列 和 数字转义序列
字符转义序列: \a, \b, \n, \r, \t

数字转义序列:
八进制转义序列: \033
十六进制转义序列: \x1b, \x1B


7.3.5 字符处理函数
#include <ctype.h>
toupper();
tolower();


7.3.6 用scanf 和 printf 读/写字符
char ch;
scanf("%c", &ch);
printf("%c", ch);


7.3.7 用getchar 和 putchar 读/写字符
可以使用getchar函数和 putchar函数来取代scanf函数和printf函数。
putchar函数用于写单个字符:
putchar(ch);

getchar()函数用于读取单个字符, 并将其返回。
为了保存这个字符, 必须使用赋值操作将其存储到变量中:
ch = getchar();
事实上, getchar()函数返回的是一个int类型的值而不是char类型的值。

和scanf函数一样, getchar函数也不会在读取时跳过空白字符。

执行程序时, 使用getchar函数和putchar函数(胜于scanf函数和printf函数)
可以节约时间。

[惯用法]:
while(getchar() != '\n) /* skips rest of line */
    ;


[惯用法]:
while((ch = getchar()) == ' ')  /* skips blanks */
    ;


7.4 类型转换
在执行算术运算时, 计算机比C语言的限制更多.
为了让计算机执行算术运算, 通常要求操作数有相同的大小(即位的数量相同),
并且要求存储的方式也相同。计算机可能可以直接将两个16位整数相加,
但是不能直接将16位整数和32位整数相加, 也不能直接将32位整数和32位浮点数相加。

C语言则允许在表达式中混合使用基本类型.在单个表达式中可以组合整数、浮点数,
甚至是字符。当然, 在这种情况下C编译器可能需要生成一些指令将某些操作数转换成
不同类型, 使得硬件可以对表达式进行计算。
例如, 如果对16位short型数和32位int型数进行加法操作, 
那么编译器将安排把16位short型值转换成32位值。

因为编译器可以自动处理这些转换而无需程序员介入, 所以这类转换称为隐式转换。
C语言还允许程序员使用强制运算符执行显式转换。

7.4.1 常用算术转换
为了统一操作数的类型, 通常可以将相对较狭小类型的操作数转换成
另一个操作数的类型来实现。(这就是所谓的提升)


7.4.2 赋值过程中的转换
常用算术转换不适用于赋值运算。
C语言会遵循另一条简单的转换规则, 
那就是把赋值运算右边的表达式转换成左边变量的类型。


7.4.3 C99中的隐式转换


7.4.4 强制类型转换
[强制转换表达式] (类型名) 表达式


7.5 类型定义
typedef int Bool;

typedef double Dollars;

在C99中, <stdint.h>头使用typedef定义占用特定位数的整数类型名.
例如, int32_t是恰好占用32位的有符号整数。


7.6 sizeof运算符
sizeof运算符允许程序存储指定类型值所需空间的大小. 表达式
[sizeof表达式]  sizeof(类型名)
的值是一个无符号整数, 代表存储属于类型名的值所需要的字节数。

表达式sizeof(char) 的值始终为1, 但是对其他类型计算出的值可能会有所不同。
在32位的机器上, 表达式sizeof(int)的值通常为4.

sizeof表达式的类型是size_t, 这是一种由实现定义的类型.


=========================================================
=========================================================
问与答:
问: 为什么使用%lf读取double类型的值, 而用%f进行显式呢?
答: 首先, scanf函数和printf函数都是不同寻常的函数, 因为它们都没有将函数的参数
    限制为固定数量. scanf函数和printf函数有可变长度的参数列表. 当调用带有可变长度
    参数列表的函数时, 编译器会安排float参数自动转换成double类型, 其结果是
    printf函数无法区分float类型和double类型的参数.
    这解释了在printf函数调用中为何可以用%f既表示float类型又表示double类型的参数。

    另一方面, scanf函数是通过指针指向变量的. %f告诉scanf函数在所传地址位置上存储一个
    float类型值, 而%lf告诉scanf函数在该地址上存储一个double类型值.
    这里float和double的区别是非常重要的. 如果给出了错误的转换说明, 
    那么scanf函数将可能存储错误的字节数量.


问: 为什么C语言要提供类型定义呢? 定义一个BOOL宏不是和用typedef定义一个Bool类型一样好用吗？
答: 首先, 类型定义比宏定义功能更强大. 特别是, 数组和指针类型是不能定义为宏的。
    假设我们试图使用宏来定义一个"指向整数的指针"类型:
    #define PTR_TO_INT  int *
    声明
    PTR_TO_INT p, q, r;
    在处理以后将会变成
    int * p, q, r;
    可惜的是, 只有p是指针, q和r都成了普通的整型变量.

    其次, typedef命名的对象具有和变量相同的作用域规则: 
    定义在函数体内的typedef名字在函数外是无法识别的.

