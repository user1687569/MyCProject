11.1 指针变量
大多数现代计算机都将内存分割为字节(byte), 
每个字节可以存储8位的信息.
0 1 0 1 0 0 1 1

每个字节都有唯一的地址(address), 用来和内存中的其他字节相区别.

可执行程序由代码和数据两部分组成。
代码: 原始C程序中与语句对应的机器指令
数据: 原始程序中的变量

程序中的每个变量占有一个或多个字节内存, 
把第一个字节的地址称为是变量的地址.

这就是指针的出处. 虽然用数表示地址, 但是地址的取值范围可能不同于整数的范围,
所以一定不能用普通整型变量存储地址.
但是, 可以用特殊的指针变量(pointer variable)存储地址.

在用指针变量p存储变量i的地址时, 我们说p "指向" i.
换句话说, 指针就是地址, 而指针变量就是存储地址的变量.

指针变量的声明
int *p;

11.2 取地址运算符 和 间接寻址运算符
&(取地址)运算符. 如果x是变量, 那么&x就是x在内存中的地址.
*(间接寻址)运算符. 如果p是指针, 那么*p表示p当前指向的对象.

int *p;
在使用前初始化p是至关重要的.

==================================================
不要把间接寻址运算符用于未初始化的指针变量.
如果指针变量p没有初始化, 那么试图使用p的值会导致未定义的行为:
int *p;
printf("%d", *p);   /* WRONG */

给*p赋值尤其危险. 如果p恰好具有有效的内存地址,
下面的赋值会试图修改存储在该地址的数据:
int *p;
*p = 1; /* WRONG */

如果上述赋值改变的内存单元属于该程序, 那么可能会导致不规律的行为;
如果改变的内存单元属于操作系统, 那么很可能会导致系统崩溃.


11.3 指针赋值
C语言允许使用赋值运算符进行指针的赋值, 
前提是两个指针具有相同的类型.
int i, j, *p, *q;
p = &i;

下面是一个指针赋值的示例:
q = p;


11.4 指针作为参数
void max_min(int a[], int n, int *max, int *min);

用const保护参数
可以使用单词const来表明函数不会改变指针参数所指向的对象.
const应放置在形式参数的声明中, 后面紧跟着形式参数的类型说明.
void f(const int *p);


11.5 指针作为返回值
int *max(int *a, int *b)
{
    if(*a > *b)
        return a;
    else
        return b;
}

=================================================
永远不要返回指向自动局部变量的指针:
int *f(void)
{
    int i;
    ...
    return &i;  /* WRONG */
}


=================================================
问与答
问: 如果指针可以指向程序中的数据, 那么使指针指向程序代码是否可能?
答: 可能.

问: 有没有办法显式变量的地址?
答: 任何指针(包括变量的地址)都可以通过调用printf函数并在格式串中使用
    转换说明%p来显示.


=================================================
问: 下列声明使人糊涂:
    void f(const int *p);
    这是说明函数f不能修改p吗?
答: 不是. 这说明不能改变指针p指向的整数, 但是并不阻止f改变p自身.
void f(const int *p)
{
    int j;

    *p = 0;     /* WRONG */
    p = &j;     /* legal */
}


=================================================
问: 声明指针类型的形式参数时, 像下面这样在参数名前面放置
单词const是否合法?
答: 是合法的.
    在p的类型前面放置const可以保护p指向的对象.
    在p的类型后面放置const可以保护p本身.
void f(int * const p)
{
    int j;
    *p = 0;     /* legal */
    p = &j;     /* WRONG */
}


void f(const int * const p)
{
    int j;

    *p = 0;     /* WRONG */
    p = &j;     /* WRONG */
}



